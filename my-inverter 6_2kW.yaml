substitutions:
  name: Inverter
  device_name: "inverter"
  friendly_name: "My Inverter"
  device_description: "Monitor and control an Inverter"
  node_name: "Inverter"
  node_id: inverter
  inverter_tx_pin: GPIO17
  inverter_rx_pin: GPIO18
  inverter_voltage_offset: "0"
  update_interval: 10s # Minimum 10s recommended to avoid duplicate command errors
#  heartbeat: 7s
  select_skip_updates: "10"

esphome:
  name: "${device_name}"
  friendly_name: "${node_name}"
  comment: "Monitor and control a solar inverter"
  includes:
    - "helpers"
  project:
    name: "esphome.hybrid-inverter"
    version: 1.3.3
  platformio_options:
    board_build.flash_mode: dio
    board_build.flash_size: 8MB

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf
    #type: arduino
    # Custom sdkconfig options
    sdkconfig_options:
      # #COMPILER_OPTIMIZATION_SIZE: y
      COMPILER_OPTIMIZATION_PERF: y
    # # Advanced tweaking options
    # #advanced:
      # #ignore_efuse_mac_crc: false
  flash_size: 8MB

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "${node_name} Fallback"
    password: !secret ap_password

captive_portal:

packages:
  # You can replace next 2 lines with your common configs for all devices
 # common_system: !include includes/common_system.yaml
  common_sensors: !include includes/common_sensors.yaml
  
ota:
  platform: esphome

logger:
 # id: uart_logger
  baud_rate: 0
  level: DEBUG #VERBOSE
  logs:
    component: ERROR # Fix for issue #4717 "Component xxxxxx took a long time for an operation"

time:
  - platform: homeassistant
    id: esptime

web_server:
 port: 80
 local: true
 version: 3
 auth:
    username: !secret web_server_username
    password: !secret web_server_password
#  ota: false  

api:
  
uart:
  # - id: uart_pzem
    # baud_rate: 9600
    # tx_pin: ${pzem_tx_pin}
    # rx_pin: ${pzem_rx_pin}
    # debug:
     # direction: BOTH
     # dummy_receiver: false
     # after:
      # delimiter: "\n"
     # sequence:
      # - lambda: UARTDebug::log_string(direction, bytes);

  - id: uart_inverter
    baud_rate: 2400
    tx_pin: ${inverter_tx_pin}
    rx_pin: ${inverter_rx_pin}
    data_bits: 8
    parity: NONE
    stop_bits: 1
    rx_buffer_size: 512
#    debug:
#     direction: BOTH
 
modbus:
  - id: modbus_inverter
    uart_id: uart_inverter
    send_wait_time: 1000ms #min 250ms
    

 
  # - id: modbus_pzem
    # uart_id: uart_pzem
    # send_wait_time: 250ms

modbus_controller:
  - id: smg_inverter
    address: 0x05
    modbus_id: modbus_inverter
#    command_throttle: 1s
    setup_priority: -10
    offline_skip_updates: 10
    update_interval: ${update_interval}
  
  # - id: pzem
    # # The current device address.
    # address: 0x02
    # # The special address 0xF8 is a broadcast address accepted by any pzem device,
    # # so if you use this address, make sure there is only one pzem device connected
    # # to the uart bus.
    # # address: 0xF8
    # modbus_id: modbus_pzem
    # command_throttle: 0ms
    # setup_priority: -10
    # offline_skip_updates: 100
    # update_interval: ${pzem_update_interval}

sensor:

  - platform: total_daily_energy
    name: "Daily Energy"
    icon: mdi:transmission-tower-export
    restore: true
    power_id: load_power
    unit_of_measurement: 'kWh'
    state_class: total_increasing
    device_class: energy
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: total_daily_energy
    name: "PV Daily Energy"
    icon: mdi:solar-power-variant
    restore: true
    power_id: pv_power
    unit_of_measurement: 'kWh'
    state_class: total_increasing
    device_class: energy
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: total_daily_energy
    name: "Battery Daily Charge Energy"
    icon: mdi:battery-arrow-down-outline
    restore: true
    power_id: battery_charge_power
    unit_of_measurement: 'kWh'
    state_class: total_increasing
    device_class: energy
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: total_daily_energy
    name: "Battery Daily Discharge Energy"
    icon: mdi:battery-arrow-up
    restore: true
    power_id: battery_discharge_power
    unit_of_measurement: 'kWh'
    state_class: total_increasing
    device_class: energy
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # - platform: pzemac
    # modbus_id: modbus_pzem
    # voltage:
      # name: "Grid Voltage PZEM"
      # id: pzem_grid_voltage
      # #internal: true
      # #filters:
      # #  - &mafilter quantile:
      # #      window_size: 5
      # #      send_every: 1
      # #      send_first_at: 1
      # #      quantile: .9
      # #  - offset: ${pzem_voltage_offset}
    # current:
      # name: "Grid Current PZEM"
      # id: pzem_grid_current
      # #filters:
      # #  - *mafilter
      # #  - offset: ${pzem_current_offset}
    # power:
      # name: "Grid Power PZEM"
      # id: pzem_grid_power
      # #filters:
      # #  - *mafilter
    # power_factor:
      # name: "Grid Power Factor PZEM"
      # id: pzem_grid_power_factor
      # #filters:
      # #  - *mafilter
    # energy:
      # name: "Grid Energy PZEM"
      # id: pzem_grid_energy
      # #filters:
      # #  - *mafilter

  # - platform: template
    # name: "Grid Power VA PZEM"
    # unit_of_measurement: "W"
    # device_class: power
    # state_class: measurement
    # accuracy_decimals: 0
    # update_interval: ${pzem_update_interval}
    # lambda: |-
      # return id(pzem_grid_current).state * id(pzem_grid_voltage).state;

  # - platform: template
    # name: "Grid Power VA*PF PZEM"
    # unit_of_measurement: "W"
    # device_class: power
    # state_class: measurement
    # accuracy_decimals: 0
    # update_interval: ${pzem_update_interval}
    # lambda: |-
      # return id(pzem_grid_current).state * id(pzem_grid_voltage).state * id(pzem_grid_power_factor).state;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Grid Voltage"
    icon: mdi:transmission-tower
    address: 4502
    register_type: holding
    force_new_range: true
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
        float voltage = swapBytes(x) * 0.1 + ${inverter_voltage_offset};
        if ((voltage >= 170.0 && voltage <= 280.0) || voltage == 0.0) {
            return voltage;
        }
        return NAN;
  
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Grid Frequency"
    icon: mdi:sine-wave
    address: 4503
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "Hz"
    device_class: frequency
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
        float frequency = swapBytes(x) * 0.1;
        if (frequency >= 40.0 && frequency <= 60.0) {
          return frequency;
        }
        return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: pv_voltage
    name: "PV Voltage"
    icon: mdi:flash-triangle-outline
    address: 4504
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      float voltage = swapBytes(x) * 0.1;
      if (voltage >= 0.0 && voltage <= 600.0) {
        return voltage;
      }
        return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: pv_power
    name: "PV Power"
    icon: mdi:sun-angle
    address: 4505
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      float power = swapBytes(x);
      if (power >= 0.0 && power <= 10000.0) {
        return power;
      }
        return NAN;

  - platform: template
    id: PV_Current
    name: "PV Current"
    icon: mdi:solar-power
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    accuracy_decimals: 1
    update_interval: ${update_interval}
    lambda: |-
      if (id(pv_voltage).state == 0) {
        return 0;
      }
      return id(pv_power).state / id(pv_voltage).state;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Battery Voltage"
    icon: mdi:battery-medium
    id: battery_voltage
    address: 4506
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 2
    lambda: |-
      float voltage = swapBytes(x) * 0.1;
      if (voltage >= 30.0 && voltage <= 60.0) {
        return voltage;
      }
        return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Battery SoC"
    icon: mdi:battery
    accuracy_decimals: 0
    unit_of_measurement: "%"
    device_class: battery
    address: 4507
    register_type: holding
    value_type: U_WORD
    state_class: measurement
    lambda: |-
      float soc = swapBytes(x);
      if (soc >= 0.0 && soc <= 100.0) {
        return soc;
      }
        return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: Battery Charge Current
    id: battery_charge_current
    address: 4508
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    accuracy_decimals: 1
    internal: true
    lambda: |-
      float current = swapBytes(x);
      if (current >= 0.0 && current <= 200.0) {
        return current;
      }
        return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Battery Discharge Current"
    id: battery_discharge_current
    address: 4509
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    accuracy_decimals: 1
    internal: true
    lambda: |-
      float current = swapBytes(x);
      if (current >= 0.0 && current <= 200.0) {
        return current;
      }
        return NAN;
 
  - platform: template
    name: "Battery Current"
    id: battery_current
    icon: mdi:current-dc
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    accuracy_decimals: 1
    update_interval: ${update_interval}
    lambda: |-
      return id(battery_charge_current).state - id(battery_discharge_current).state;

  - platform: template
    name: "Battery Power"
    icon: mdi:battery-charging-medium
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    update_interval: ${update_interval}
    lambda: |-
      return id(battery_current).state * id(battery_voltage).state;

  - platform: template
    name: "Battery Charge Power"
    id: battery_charge_power
    icon: mdi:battery-arrow-down-outline
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    update_interval: ${update_interval}
    lambda: |-
      return id(battery_charge_current).state * id(battery_voltage).state;

  - platform: template
    name: "Battery Discharge Power"
    id: battery_discharge_power
    icon: mdi:battery-arrow-up
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    update_interval: ${update_interval}
    lambda: |-
      return id(battery_discharge_current).state * id(battery_voltage).state;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Load Voltage"
    id: load_voltage
    icon: mdi:meter-electric-outline
    address: 4510
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      float voltage = swapBytes(x) * 0.1;
      if (voltage >= 170.0 && voltage <= 280.0) {
        return voltage;
      }
        return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Load Frequency"
    icon: mdi:sine-wave
    address: 4511
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "Hz"
    device_class: frequency
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      float frequency = swapBytes(x) * 0.1;
      if (frequency >= 40.0 && frequency <= 60.0) {
        return frequency;
      }
        return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Load Power VA"
    id: load_Power_VA
    icon: mdi:gauge
    address: 4512
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "VA"
    device_class: apparent_power
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      float power_va = swapBytes(x);
      if (power_va >= 0.0 && power_va <= 10000.0) {
        return power_va;
      }
        return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Load Power"
    id: load_power
    icon: mdi:home-lightning-bolt
    address: 4513
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      float power = swapBytes(x);
      if (power >= 0.0 && power <= 10000.0) {
        return power;
      }
        return NAN;

  - platform: template
    name: "Load Current"
    id: load_current
    icon: mdi:current-ac
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    accuracy_decimals: 3
    update_interval: ${update_interval}
    lambda: |-
      if (id(load_voltage).state == 0) {
        return 0;
      }
      return id(load_Power_VA).state / id(load_voltage).state;

  - platform: template
    name: "Load Power Factor"
    id: load_power_factor
    icon: mdi:math-cos
    device_class: power_factor
    state_class: measurement
    accuracy_decimals: 2
    update_interval: ${update_interval}
    lambda: |-
      if (id(load_power).state == 0) {
        return 0;
      }
      return id(load_power).state / id(load_Power_VA).state;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "AC Output Load %"
    icon: mdi:chart-bell-curve-cumulative
    address: 4514
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"
    device_class: power_factor
    state_class: measurement
    lambda: |-
      float output_load_percentage = swapBytes(x);
      if (output_load_percentage >= 0.0 && output_load_percentage <= 100.0) {
        return output_load_percentage;
      }
        return NAN;
      
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Load Percent"
    icon: mdi:home-percent-outline
    address: 4515
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"
    device_class: power_factor
    state_class: measurement
    lambda: |-
      float load_percent = swapBytes(x);
      if (load_percent >= 0.0 && load_percent <= 100.0) {
        return load_percent;
      }
        return NAN;

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Binary Flags" #overload?
    # address: 4516
    # entity_category: diagnostic
    # internal: true
    # register_type: holding
    # bitmask: 0xFFFF
    # value_type: "U_WORD"

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Main CPU version"
    # icon: mdi:chip
    # entity_category: diagnostic
    # address: 4518
    # register_type: holding
    # value_type: U_WORD
    # lambda: |-
      # return swapBytes(x);

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Secondary CPU version"
    # icon: mdi:chip
    # entity_category: diagnostic
    # address: 4519
    # register_type: holding
    # value_type: U_WORD
    # lambda: |-
      # return swapBytes(x);

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Nominal output apparent power"
    # entity_category: diagnostic
    # unit_of_measurement: "VA"
    # device_class: apparent_power
    # address: 4521
    # register_type: holding
    # value_type: U_WORD
    # lambda: |-
      # return swapBytes(x);

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Nominal output active power"
    # entity_category: diagnostic
    # unit_of_measurement: "W"
    # device_class: power
    # address: 4522
    # register_type: holding
    # value_type: U_WORD
    # lambda: |-
      # return swapBytes(x);

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Nominal AC voltage"
    # entity_category: diagnostic
    # unit_of_measurement: "V"
    # device_class: voltage
    # address: 4523
    # register_type: holding
    # value_type: U_WORD
    # lambda: |-
      # return swapBytes(x);

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Nominal AC current"
    # entity_category: diagnostic
    # unit_of_measurement: "A"
    # device_class: current
    # address: 4524
    # register_type: holding
    # value_type: U_WORD
    # lambda: |-
      # return swapBytes(x);

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Rated battery voltage"
    # entity_category: diagnostic
    # unit_of_measurement: "V"
    # device_class: voltage
    # address: 4525
    # register_type: holding
    # value_type: U_WORD
    # lambda: |-
      # return swapBytes(x);
    # filters:
      # - multiply: 0.1

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Nominal output voltage"
    # entity_category: diagnostic
    # unit_of_measurement: "V"
    # device_class: voltage
    # address: 4526
    # register_type: holding
    # value_type: U_WORD
    # lambda: |-
      # return swapBytes(x);

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Nominal output frequency"
    # entity_category: diagnostic
    # unit_of_measurement: "Hz"
    # device_class: frequency
    # address: 4527
    # register_type: holding
    # value_type: U_WORD
    # lambda: |-
      # return swapBytes(x);
    # filters:
      # - multiply: 0.1

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Nominal output current"
    # entity_category: diagnostic
    # unit_of_measurement: "A"
    # device_class: current
    # address: 4528
    # register_type: holding
    # value_type: U_WORD
    # lambda: |-
      # return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Error Register"
    entity_category: diagnostic
    id: error_register
    address: 4529
    register_type: holding
    value_type: U_WORD
    internal: true
    on_value:
      then:
        - lambda: |-
            uint16_t errors = x;
            static const std::vector<std::pair<uint16_t, std::string>> error_messages = {
                {0x0001, "Bus Soft Failed"},
                {0x0002, "PV Voltage High"},
                {0x0004, "Over Current"},
                {0x0008, "Bus Voltage Under"},
                {0x0010, "INV Soft Failed"},
                {0x0020, "DC Voltage Over"},
                {0x0040, "CT Fault"},
                {0x0080, "INV Voltage Low"},
                {0x0100, "Fan Locked"},
                {0x0200, "Over Temperature"},
                {0x0400, "Battery Voltage High"},
                {0x0800, "Battery Voltage Low"},
                {0x1000, "Output Shorted"},
                {0x2000, "INV Voltage Over"},
                {0x4000, "Over Load"},
                {0x8000, "Bus Voltage Over"}
            };

            std::vector<std::string> active_errors;
            for (const auto& [mask, message] : error_messages) {
                if (errors & mask) {
                    active_errors.push_back(message);
                }
            }

            std::string result = active_errors.empty() ? "No errors" : "";
            for (const auto& error : active_errors) {
                if (!result.empty()) {
                    result += "; ";
                }
                result += error;
            }

            id(error_register_status).publish_state(result);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Alarm Register"
    entity_category: diagnostic
    address: 4530
    register_type: holding
    value_type: U_WORD
    internal: true
    on_value:
      then:
        - lambda: |-
            uint16_t alarms = x;
            static const std::vector<std::pair<uint16_t, std::string>> alarm_messages = {
                {0x0001, "No Battery"},
                {0x0100, "Fan Locked"},
                {0x0200, "Over Temperature"},
                {0x0400, "Battery Over Charged"},
                {0x0800, "Battery Voltage Low"},
                {0x1000, "Over Load"},
                {0x2000, "Output Power Derating"},
                {0x4000, "PV Energy Weak"},
                {0x8000, "AC Voltage High"}
            };

            std::vector<std::string> active_alarms;
            for (const auto& [mask, message] : alarm_messages) {
                if (alarms & mask) {
                    active_alarms.push_back(message);
                }
            }

            std::string result = active_alarms.empty() ? "No alarms" : "";
            for (const auto& alarm : active_alarms) {
                if (!result.empty()) {
                    result += "; ";
                }
                result += alarm;
            }

            id(active_alarms_status).publish_state(result);


  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "ID1"
    # icon: mdi:identifier
    # entity_category: diagnostic
    # address: 4531
    # register_type: holding
    # value_type: U_WORD
    # lambda: |-
      # return swapBytes(x);

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "ID2"
    # icon: mdi:identifier
    # entity_category: diagnostic
    # address: 4532
    # register_type: holding
    # value_type: U_WORD
    # lambda: |-
      # return swapBytes(x);

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "ID3"
    # icon: mdi:identifier
    # entity_category: diagnostic
    # address: 4533
    # register_type: holding
    # value_type: U_WORD
    # lambda: |-
      # return swapBytes(x);

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "ID4"
    # icon: mdi:identifier
    # entity_category: diagnostic
    # address: 4534
    # register_type: holding
    # value_type: U_WORD
    # lambda: |-
      # return swapBytes(x);
      
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Status Flags"
    id: status_flags
    entity_category: diagnostic
    internal: true
    address: 4535
    register_type: holding
    bitmask: 0xFFFF
    value_type: "U_WORD"

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Target Output Frequency"
    icon: mdi:cosine-wave
    accuracy_decimals: 0
    entity_category: diagnostic
    address: 4540
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "Hz"
    lambda: |-
      uint16_t value = swapBytes(x);
      return (value == 0) ? 50.0 : (value == 1) ? 60.0 : NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Max Total Charging Current"
    accuracy_decimals: 0
    icon: mdi:battery-charging-100
    address: 4541
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "A"
    lambda: |-
      float total_current = swapBytes(x);
      if (total_current >= 10.0 && total_current <= 150.0) {
        return total_current;
      }
      return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Target Output Voltage"
    icon: mdi:sine-wave
    accuracy_decimals: 0
    entity_category: diagnostic
    address: 4542
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    lambda: |-
      float voltage = swapBytes(x);
      if (voltage >= 220.0 && voltage <= 240.0) {
        return voltage;
      }
      return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Max Utility Charging Current"
    icon: mdi:transmission-tower-export
    accuracy_decimals: 0
    address: 4543
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "A"
    lambda: |-
      float utility_current = swapBytes(x);
      if (utility_current >= 2.0 && utility_current <= 120.0) {
        return utility_current;
      }
      return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Back To Utility Source Voltage"
    icon: mdi:transmission-tower-import
    accuracy_decimals: 1
    entity_category: diagnostic
    address: 4544
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    lambda: |-
      float voltage = swapBytes(x) * 0.1;
      if (voltage >= 42.0 && voltage <= 51.0) {
        return voltage;
      }
      return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Back To Battery Source Voltage"
    icon: mdi:power-plug-battery
    accuracy_decimals: 1
    entity_category: diagnostic
    address: 4545
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    lambda: |-
      float voltage = swapBytes(x) * 0.1;
      if (voltage >= 48.0 && voltage <= 58.0) {
        return voltage;
      }
      return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Charging Voltage Bulk"
    icon: mdi:battery-arrow-down
    accuracy_decimals: 1
    address: 4546
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    lambda: |-
      float voltage = swapBytes(x) * 0.1;
      if (voltage >= 48.0 && voltage <= 58.0) {
        return voltage;
      }
      return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Charging Voltage Float"
    icon: mdi:battery-sync-outline
    accuracy_decimals: 1
    address: 4547
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    lambda: |-
      float voltage = swapBytes(x) * 0.1;
      if (voltage >= 48.0 && voltage <= 58.0) {
        return voltage;
      }
      return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Low CutOff Voltage"
    icon: mdi:battery-off
    accuracy_decimals: 1
    entity_category: diagnostic
    address: 4548
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    lambda: |-
      float voltage = swapBytes(x) * 0.1;
      if (voltage >= 40.0 && voltage <= 48.0) {
        return voltage;
      }
      return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Equalization Voltage"
    icon: mdi:battery-medium
    accuracy_decimals: 1
    address: 4549
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    lambda: |-
      float voltage = swapBytes(x) * 0.1;
      if (voltage >= 48.0 && voltage <= 61.0) {
        return voltage;
      }
      return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Equalized Time"
    icon: mdi:battery-clock-outline
    accuracy_decimals: 0
    entity_category: diagnostic
    address: 4550
    register_type: holding
    value_type: U_WORD
    lambda: |-
      float eq_time = swapBytes(x);
      if (eq_time >= 0.0 && eq_time <= 900.0) {
        return eq_time;
      }
      return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Equalized Timeout"
    icon: mdi:battery-remove-outline
    accuracy_decimals: 0
    entity_category: diagnostic
    address: 4551
    register_type: holding
    value_type: U_WORD
    lambda: |-
      float eq_timeout = swapBytes(x);
      if (eq_timeout >= 5.0 && eq_timeout <= 900.0) {
        return eq_timeout;
      }
      return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Equalization Interval"
    icon: mdi:update
    accuracy_decimals: 0
    entity_category: diagnostic
    address: 4552
    register_type: holding
    value_type: U_WORD
    lambda: |-
      float interval = swapBytes(x);
      if (interval >= 0.0 && interval <= 90.0) {
        return interval;
      }
      return NAN;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "States"
    id: states
    entity_category: diagnostic
    address: 4553
    register_type: holding
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Value 4554"
    id: grid_active_value
    address: 4554
    register_type: holding
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "DC Temperature"
    icon: mdi:thermometer-lines
    accuracy_decimals: 0
    entity_category: diagnostic
    address: 4557
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    lambda: |-
      float temperature = swapBytes(x);
      if (temperature >= -30.0 && temperature <= 100.0) {
        return temperature;
      }
      return NAN;

binary_sensor:

  - platform: template
    name: "Record Fault Code State"
    icon: mdi:alert-circle
    lambda: |-
      return (int(id(status_flags).state) & 0x1) ? 1 : 0;
    entity_category: diagnostic

  - platform: template
    name: "Equalization State"
    icon: mdi:check-circle
    lambda: |-
      return (int(id(status_flags).state) & 0x2) ? 1 : 0;
    entity_category: diagnostic

  - platform: template
    name: "Equalization Activated Immediately State"
    icon: mdi:clock-alert
    lambda: |-
      return (int(id(status_flags).state) & 0x4) ? 1 : 0;
    entity_category: diagnostic

  - platform: template
    name: "Alarm State"
    icon: mdi:alarm-light
    lambda: |-
      return (int(id(status_flags).state) & 0x100) ? 1 : 0;
    entity_category: diagnostic

  - platform: template
    name: "Backlight State"
    icon: mdi:lightbulb
    lambda: |-
      return (int(id(status_flags).state) & 0x400) ? 1 : 0;
    entity_category: diagnostic

  - platform: template
    name: "Restart On Overload State"
    icon: mdi:restart
    lambda: |-
      return (int(id(status_flags).state) & 0x800) ? 1 : 0;
    entity_category: diagnostic

  - platform: template
    name: "Restart On Overheat State"
    icon: mdi:fire
    lambda: |-
      return (int(id(status_flags).state) & 0x1000) ? 1 : 0;
    entity_category: diagnostic

  - platform: template
    name: "Beep On Primary Source Fail State"
    icon: mdi:volume-high
    lambda: |-
      return (int(id(status_flags).state) & 0x2000) ? 1 : 0;
    entity_category: diagnostic

  - platform: template
    name: "Return To Default Screen State"
    icon: mdi:screen-rotation-lock
    lambda: |-
      return (int(id(status_flags).state) & 0x4000) ? 1 : 0;
    entity_category: diagnostic

  - platform: template
    name: "Overload Bypass State"
    icon: mdi:power-plug
    lambda: |-
      return (int(id(status_flags).state) & 0x8000) ? 1 : 0;
    entity_category: diagnostic

  - platform: template
    name: "On Grid"
    id: on_grid
    icon: mdi:transmission-tower-import
    lambda: |-
        return id(grid_active_value).state == 0x0200 ? 1 : 0;

  - platform: template
    name: "On Battery"
    id: on_battery
    icon: mdi:transmission-tower-off
    lambda: |-
        return id(grid_active_value).state == 0x0700 ? 1 : 0;
  
  ####################################
  #      Read config registers       #
  ####################################

text_sensor:

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: Working_State
    name: "Working State"
    icon: mdi:state-machine
    address: 4501
    register_type: holding
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t sensorIndex = swapBytes(modbus_controller::word_from_hex_str(x, 0));
      static const char* working_states[] = {
        "Power On", "Test", "Stand By", "Invert Mode", 
        "Line Mode", "Bypass", "Fault Mode", "ShutDown"
      };
      if (sensorIndex < 8) {
        return {working_states[sensorIndex]};
      }
      return {};
#      if (sensorIndex == UINT16_MAX) {
#        return {};
#      }

#      switch (sensorIndex) {
#        case 0: return std::string("Power On");
#        case 1: return std::string("Test");
#        case 2: return std::string("Stand By");
#        case 3: return std::string("Invert Mode");
#        case 4: return std::string("Line Mode");
#        case 5: return std::string("Bypass");
#        case 6: return std::string("Fault Mode");
#        case 7: return std::string("ShutDown");
#        default: return std::string(x);
#      }   

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # id: Machine_Type
    # name: "Machine Type"
    # icon: mdi:memory
    # entity_category: diagnostic
    # address: 4517
    # register_type: holding
    # response_size: 2
    # raw_encode: HEXBYTES
    # lambda: |-
      # uint16_t sensorIndex = swapBytes(modbus_controller::word_from_hex_str(x, 0));
      # switch (sensorIndex) {
        # case 0: return std::string("Solar Inverter");
        # case 1: return std::string("Voltage regulator");
        # default: return std::string(x);
      # }

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # id: Battery_Piece
    # name: "Battery Piece"
    # icon: mdi:battery
    # entity_category: diagnostic
    # address: 4520
    # register_type: holding
    # response_size: 2
    # raw_encode: HEXBYTES
    # lambda: |-
      # uint16_t sensorIndex = swapBytes(modbus_controller::word_from_hex_str(x, 0));
      # switch (sensorIndex) {
        # case 0: return std::string("No Battery");
        # case 1: return std::string("24V");
        # case 2: return std::string("48V");
        # default: return std::string(x);
      # }

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: charger_source_priority_text
    name: "Charger Source"
    icon: mdi:ev-station
    address: 4536
    register_type: holding
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t sensorIndex = swapBytes(modbus_controller::word_from_hex_str(x, 0));
      static const char* source_options[] = {"Solar first", "Solar and Utility", "Only solar"};
      if (sensorIndex < 3) {
        return {source_options[sensorIndex]};
      }
      return {};

#      if (sensorIndex == UINT16_MAX) {
#        return {};
#      }

#      switch (sensorIndex) {
#        case 0: return std::string("Solar first");
#        case 1: return std::string("Solar and Utility");
#        case 2: return std::string("Only solar");
#        default: return std::string(x);
#      }

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Output Source"
    icon: mdi:export
    address: 4537
    register_type: holding
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t sensorIndex = swapBytes(modbus_controller::word_from_hex_str(x, 0));
      static const char* sensorStates[] = {"Utility first (USB)", "Solar first (SUB)", "SBU priority"};
      if (sensorIndex <= 2) {
        return std::string(sensorStates[sensorIndex]);
      }
      return {};
#      if (sensorIndex == 0 || sensorIndex == 1 || sensorIndex == 2) {
#        switch (sensorIndex) {
#          case 0: return std::string("Utility first (USB)");
#          case 1: return std::string("Solar first (SUB)");
#          case 2: return std::string("SBU priority");
#        }
#      }
#      return {};

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "AC Input Voltage Range"
    icon: mdi:home-import-outline
    entity_category: diagnostic
    address: 4538
    register_type: holding
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t value = swapBytes(modbus_controller::word_from_hex_str(x, 0));
      static const char* ranges[] = {"APL: 90-280 V", "UPS: 170-280 V"};
      if (value <= 1) {
        return std::string(ranges[value]);
      }
      return {};
#      if (value == 0 || value == 1) {
#        switch (value) {
#          case 0: return std::string("APL: 90-280 V");
#          case 1: return std::string("UPS: 170-280 V");
#        }
#      }
#      return {};

#  - platform: modbus_controller
#    modbus_controller_id: smg_inverter
#    name: "Battery type"
#    icon: mdi:home-battery
#    entity_category: diagnostic
#    address: 4539
#    register_type: holding
#    response_size: 2
#    raw_encode: HEXBYTES
#    lambda: |-
#      uint16_t value = swapBytes(modbus_controller::word_from_hex_str(x, 0));
#      switch (value) {
#        case 0: return std::string("AGM");
#        case 1: return std::string("Flooded");
#        case 2: return std::string("User defined");
#        default: return std::string(x);
#      }

  - platform: template
    name: "Battery Mode"
    icon: mdi:battery-unknown
    entity_category: diagnostic
    lambda: |-
      int16_t reg = id(states).state;
      int sensor1 = (reg >> 8) & 0x03;
      // uint8_t sensor1 = (reg >> 8) & 0x3; //reg & 0x3;
      static const char* states[] = {"Disconnected", "Discharging", "Charging", "Ok"};
      return std::string(states[sensor1]);
#      if (sensor1 == 0) return std::string("Disconnected");
#      if (sensor1 == 1) return std::string("Discharging");
#      if (sensor1 == 2) return std::string("Charging");
#      if (sensor1 == 3) return std::string("Ok");
#      return {};

  - platform: template
    name: "PV State"
    icon: mdi:solar-power
    entity_category: diagnostic
    lambda: |-
      uint16_t reg = id(states).state;
      int sensor2 = (reg >> 10) & 0x03;
      static const char* states[] = {"Undervoltage", "Normal", "Overvoltage", "Fault"};
      return std::string(states[sensor2]);
#      if (sensor2 == 0) return std::string("Undervoltage");
#      if (sensor2 == 1) return std::string("Normal");
#      if (sensor2 == 2) return std::string("Overvoltage");
#      if (sensor2 == 3) return std::string("Fault");
#      return {};

  - platform: template
    name: "Mains Supply State"
    icon: mdi:transmission-tower
    entity_category: diagnostic
    lambda: |-
      uint16_t reg = id(states).state;
      int sensor3 = (reg >> 12) & 0x03;
      static const char* states[] = {"Grid Off", "Export", "Consumption", "Idle"};
      return std::string(states[sensor3]);
#      if (sensor3 == 0) return std::string("Grid Off");
#      if (sensor3 == 1) return std::string("Export");
#      if (sensor3 == 2) return std::string("Consumption");
#      if (sensor3 == 3) return std::string("Idle");
#      return {};

  - platform: template
    name: "Load State"
    icon: mdi:lightning-bolt-circle
    entity_category: diagnostic
    lambda: |-
      uint16_t reg = id(states).state;
      int sensor4 = (reg >> 14) & 0x03;
      static const char* states[] = {"Off", "Normal", "Overload", "Critical"};
      return std::string(states[sensor4]);
#      if (sensor4 == 0) return std::string("Off");
#      if (sensor4 == 1) return std::string("Normal");
#      if (sensor4 == 2) return std::string("Overload");
#      if (sensor4 == 3) return std::string("Critical");
#      return {};
      
  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Battery Mode"
    # id: battery_state
    # icon: mdi:battery-unknown
    # entity_category: diagnostic
    # address: 4553
    # register_type: holding
    # raw_encode: HEXBYTES
    # lambda: |-
      # uint8_t val = modbus_controller::byte_from_hex_str(x, 0);
      # val = val & 0x3;
      # ESP_LOGD("custom", "Battery Mode raw value: 0x%02X, interpreted value: %d", val, val);
      # if (val == 0 || val == 1 || val == 2 || val == 3) {
        # switch (val) {
          # case 3: return std::string("Ok");
          # case 1: return std::string("Discharging");
          # case 2: return std::string("Charging");
          # case 0: return std::string("Disconnected");
        # }
      # }
      # return {};

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "PV State" 
    # icon: mdi:solar-power
    # entity_category: diagnostic
    # address: 4553
    # register_type: holding
    # raw_encode: HEXBYTES
    # lambda: |-
      # uint8_t val = modbus_controller::byte_from_hex_str(x, 0);
      # val = val & 0xC;
      # val = val >> 2;
      # ESP_LOGD("custom", "PV State raw value: 0x%02X, interpreted value: %d", val, val);
      # if (val == 0 || val == 1 || val == 2 || val == 3) {
        # switch (val) {
          # case 3: return std::string("Ok");
          # case 1: return std::string("Discharging"); //need to edit 'discharging'?
          # case 2: return std::string("Overvoltage");
          # case 0: return std::string("Undervoltage");
        # }
      # }
      # return {};

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Mains supply State"
    # id: grid_state
    # icon: mdi:transmission-tower
    # entity_category: diagnostic
    # address: 4553
    # register_type: holding
    # raw_encode: HEXBYTES
    # lambda: |-
      # uint8_t val = modbus_controller::byte_from_hex_str(x, 0);
      # val = val & 0x30;
      # val = val >> 4;
      # ESP_LOGD("custom", "Mains Supply State raw value: 0x%02X, interpreted value: %d", val, val);
      # if (val == 0 || val == 1 || val == 2 || val == 3) {
        # switch (val) {
          # case 3: return std::string("Idle");
          # case 1: return std::string("Export"); //I dont shure about 'Export'
          # case 2: return std::string("Consumption");
          # case 0: return std::string("Grid Off");
        # }
      # }
      # return {};

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Load State"
    # id: load_state
    # icon: mdi:lightning-bolt-circle
    # entity_category: diagnostic
    # address: 4553
    # register_type: holding
    # raw_encode: HEXBYTES
    # lambda: |-
      # uint8_t val = modbus_controller::byte_from_hex_str(x, 0);
      # val = val & 0xC0;
      # val = val >> 6;
      # ESP_LOGD("custom", "Load State raw value: 0x%02X, interpreted value: %d", val, val);
      # if (val == 0 || val == 1 || val == 2) {
        # switch (val) {
          # case 0: return std::string("Off");
          # case 1: return std::string("Normal");
          # case 2: return std::string("Overload");
        # }
      # }
      # return {};

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Charger Status"
    icon: mdi:ev-station
    address: 4555
    register_type: holding
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      static const std::map<uint16_t, std::string> status_map = {
        {0x0a00, "Off"},
        {0x0c00, "Absorbtion"},
        {0x0b00, "Bulk"},
        {0x0d00, "Floating"}
      };

      uint16_t sensorIndex = modbus_controller::word_from_hex_str(x, 0);
        
      auto it = status_map.find(sensorIndex);
      if (it != status_map.end()) {
        return esphome::optional<std::string>(it->second);
      }
      return esphome::optional<std::string>("");

  - platform: template
    name: "Active Errors"
    id: error_register_status
    icon: mdi:alert
    entity_category: diagnostic

  - platform: template
    name: "Active Alarms"
    id: active_alarms_status
    icon: mdi:alert
    entity_category: diagnostic

  - platform: template
    name: "ESPtime"
    entity_category: diagnostic
    id: timeee
    icon: mdi:clock-outline
    lambda:
          char str[17];
          time_t currTime = id(esptime).now().timestamp;
          strftime(str, sizeof(str), "%d-%m-%Y %H:%M", localtime(&currTime));
          return  { str };

select:

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Buzzer Alarm"
    icon: mdi:speaker-wireless
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5002
    value_type: U_WORD
    optionsmap:
      "OFF": 0
      "ON": 1

#  - platform: modbus_controller
#    name: "Power saving mode"
#    icon: mdi:leaf-circle-outline
#    optimistic: true
#    skip_updates: ${select_skip_updates}
#    entity_category: config
#    address: 5003
#    value_type: U_WORD
#    optionsmap:
#      "Off": 0
#      "On": 1

 # - platform: modbus_controller
 #   name: "Backlight"
 #   icon: mdi:alarm-light
 #   optimistic: true
 #   skip_updates: ${select_skip_updates}
 #   entity_category: config
 #   address: 5004
 #   value_type: U_WORD
 #   force_new_range: true
 #   optionsmap:
 #     "Off": 0
 #     "On": 1

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Auto restart when overload"
    # icon: mdi:restart
    # optimistic: true
    # force_new_range: true
    # register_count: 1
    # skip_updates: ${select_skip_updates}
    # entity_category: config
    # address: 5005
    # value_type: U_WORD
    # optionsmap:
      # "OFF": 0
      # "ON": 1

  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Auto restart when overheat"
    # icon: mdi:restart-alert
    # optimistic: true
    # force_new_range: true
    # register_count: 1
    # skip_updates: ${select_skip_updates}
    # entity_category: config
    # address: 5006
    # value_type: U_WORD
    # optionsmap:
      # "OFF": 0
      # "ON": 1

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Beep On Primary Source Fail"
    icon: mdi:speaker-message
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5007
    value_type: U_WORD
    optionsmap:
      "OFF": 0
      "ON": 1

#  - platform: modbus_controller
#    name: "Return To Default Display"
#    icon: mdi:backburger
#    optimistic: true
#    skip_updates: ${select_skip_updates}
#    entity_category: config
#    address: 5008
#    value_type: U_WORD
#    force_new_range: true
#    optionsmap:
#      "Off": 0
#      "On": 1

#  - platform: modbus_controller
#    name: "Overload Bypass"
#    icon: mdi:transit-skip
#    optimistic: true
#    skip_updates: ${select_skip_updates}
#    entity_category: config
#    address: 5009
#    value_type: U_WORD
#    optionsmap:
#      "Off": 0
#      "On": 1

#  - platform: modbus_controller
#    name: "Record fault code"
#    icon: mdi:folder-alert
#    optimistic: true
#    skip_updates: ${select_skip_updates}
#    entity_category: config
#    address: 5010
#    value_type: U_WORD
#    force_new_range: true
#    optionsmap:
#      "Off": 0
#      "On": 1

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Battery Equalization"
    icon: mdi:approximately-equal
    optimistic: true
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5011
    value_type: U_WORD
    optionsmap:
      "Off": 0
      "On": 1

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Battery Equalization activated immediately"
    icon: mdi:battery-arrow-up
    optimistic: true
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5012
    value_type: U_WORD
    force_new_range: true
    optionsmap:
      "Off": 0
      "On": 1

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: charger_source_priority_select
    name: "Charger Source Priority"
    icon: mdi:ev-station
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5017
    value_type: U_WORD
    optionsmap:
      "Solar first": 0
      "Solar and Utility": 1
      "Only Solar": 2
      
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: output_source_priority_select
    name: "Output Source Priority"
    icon: mdi:export
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5018
    value_type: U_WORD
    optionsmap:
      "Utility first (USB)": 0
      "Solar first (SUB)": 1
      "SBU priority": 2

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "AC Input Voltage"
    icon: mdi:home-import-outline
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5019
    value_type: U_WORD
    optionsmap:
      "APL: 90-280 V": 0
      "UPS: 170-280 V": 1
  
  # - platform: modbus_controller
    # modbus_controller_id: smg_inverter
    # name: "Battery Type"
    # icon: mdi:car-battery
    # optimistic: true
    # force_new_range: true
    # register_count: 1
    # skip_updates: ${select_skip_updates}
    # entity_category: config
    # address: 5020
    # value_type: U_WORD
    # optionsmap:
      # "AGM": 0
      # "Flooded": 1
      # "User Defined": 2     
      # "Litium": 3 

#  - platform: modbus_controller
#    name: "Output Frequency"
#    icon: mdi:cosine-wave
#    optimistic: true
#    skip_updates: ${select_skip_updates}
#    entity_category: config
#    address: 5021
#    force_new_range: true
#    value_type: U_WORD
#    optionsmap:
#      "50Hz": 0
#      "60Hz": 1

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Max Total Charge Current"
    icon: mdi:battery-charging-100
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5022
    value_type: U_WORD
    optionsmap: # you can set from 10 to 120 with step 10
      "10": 10
      "20": 20
      "30": 30
      "40": 40
      "50": 50
      "60": 60
      "70": 70
      "80": 80
      "90": 90
      "100": 100
      "110": 110
      "120": 120

#  - platform: modbus_controller
#    name: "Output voltage"
#    icon: mdi:home-export-outline
#    optimistic: true
#    skip_updates: ${select_skip_updates}
#    entity_category: config
#    address: 5023
#    force_new_range: true
#    value_type: U_WORD
#    optionsmap:
#      "220V": 220
#      "230V": 230
#      "240V": 240

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Max Utility Charge Current"
    icon: mdi:transmission-tower-export
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5024
    value_type: U_WORD
    optionsmap: # you can set 2, and from 10 to 100 with step 10
      "2": 2
      "10": 10
      "20": 20
      "30": 30
      "40": 40
      "50": 50
      "60": 60
      "70": 70

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Back To Utility Source Voltage"
    icon: mdi:transmission-tower-import
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5025
    value_type: U_WORD
    optionsmap: # you can set from 42 to 51 with step 1
      "48": 480
      "49": 490
      "50": 500
      "51": 510
      "52": 520
      
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Back To Battery Source Voltage"
    icon: mdi:power-plug-battery
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5026
    value_type: U_WORD
    optionsmap: # you can set FULL, and from 48 to 58 with step 1
      "FULL": 0
      "49": 490
      "50": 500
      "51": 510
      "52": 520
      "53": 530
      "54": 540
      "55": 550
      "56": 560
      "57": 570
      
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Charging Voltage Bulk"
    icon: mdi:battery-arrow-down
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5027
    value_type: U_WORD
    optionsmap: # you can set from 48 to 58 with step 0.1
      "3.36 x cell 53.8 V": 538
      "3.40 x cell 54.4 V": 544
      "3.42 x cell 54.7 V": 547
      "3.45 x cell 55.2 V": 552
      "3.48 x cell 55.6 V": 556
      "3.50 x cell 56.0 V": 560
      "3.52 x cell 56.4 V": 564
      "3.55 x cell 56.8 V": 568
      "3.57 x cell 57.2 V": 572
      "3.58 x cell 57.3 V": 573
      "3.59 x cell 57.4 V": 574
      "3.60 x cell 57.6 V": 576
  
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Charging Voltage Float"
    icon: mdi:battery-sync-outline
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5028
    value_type: U_WORD
    optionsmap: # you can set from 48 to 58 with step 0.1
      "3.36 x cell 53.8 V": 538
      "3.40 x cell 54.4 V": 544
      "3.42 x cell 54.7 V": 547
      "3.45 x cell 55.2 V": 552
      "3.48 x cell 55.6 V": 556
      "3.50 x cell 56.0 V": 560
      "3.52 x cell 56.4 V": 564
      "3.55 x cell 56.8 V": 568
      "3.57 x cell 57.2 V": 572
      "3.58 x cell 57.3 V": 573
      "3.59 x cell 57.4 V": 574
      "3.60 x cell 57.6 V": 576
   
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Low DC cut-off voltage"
    icon: mdi:battery-off
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5029
    value_type: U_WORD
    optionsmap: # you can set from 40 to 48 with step 0.1
      "2.75 x cell 44.0 V": 440
      "2.8 x cell 44.8 V": 448
      "2.85 x cell 45.6 V": 456
      "2.9 x cell 46.4 V": 464
      "2.95 x cell 47.2 V": 472
      "3.0 x cell 48.0 V": 480
      
# number:
  
  # - platform: modbus_controller
    # name: "Back To Utility Source Voltage"
    # id: back_to_utility_source_voltage
    # icon: mdi:transmission-tower-import
    # skip_updates: ${select_skip_updates}
    # entity_category: config
    # address: 5025
    # value_type: U_WORD
    # force_new_range: true
    # min_value: 42.0
    # max_value: 51.0
    # step: 1
    # multiply: 10
    # lambda: |-
    #   if (isnan(x)) {
    #     return {};
    #   }
    #   return x; 

  # - platform: modbus_controller
    # name: "Back To Battery Source Voltage"
    # id: back_to_battery_source_voltage
    # icon: mdi:power-plug-battery
    # skip_updates: ${select_skip_updates}
    # entity_category: config
    # address: 5026
    # value_type: U_WORD
    # min_value: 48.0
    # max_value: 58.0
    # step: 1
    # multiply: 10
    # lambda: |-
    #   if (isnan(x)) {
    #     return {};
    #   }
    #   return x; 
  
  # - platform: modbus_controller
    # name: "Charging Voltage Bulk"
    # id: bulk_charging_voltage
    # icon: mdi:battery-arrow-down
    # skip_updates: ${select_skip_updates}
    # entity_category: config
    # address: 5027
    # value_type: U_WORD
    # force_new_range: true
    # min_value: 48.0
    # max_value: 58.0
    # step: 0.1
    # multiply: 10
    # lambda: |-
    #   if (isnan(x)) {
    #     return {};
    #   }
    #   return x; 

  # - platform: modbus_controller
    # name: "Charging Voltage Float"
    # id: floating_charging_voltage
    # icon: mdi:battery-sync-outline
    # skip_updates: ${select_skip_updates}
    # entity_category: config
    # address: 5028
    # value_type: U_WORD
    # min_value: 48.0
    # max_value: 58.0
    # step: 0.1
    # multiply: 10
    # lambda: |-
    #   if (isnan(x)) {
    #     return {};
    #   }
    #   return x; 

  # - platform: modbus_controller
    # name: "Low DC cut-off voltage"
    # id: low_dc_cut_off_voltage
    # icon: mdi:battery-off
    # skip_updates: ${select_skip_updates}
    # entity_category: config
    # address: 5029
    # value_type: U_WORD
    # force_new_range: true
    # min_value: 40.0
    # max_value: 48.0
    # step: 0.1
    # multiply: 10
    # lambda: |-
    #   if (isnan(x)) {
    #     return {};
    #   }
    #   return x; 

#Menu31 - 5030 Battery equalization voltage
  # - platform: modbus_controller
    # name: "Battery Equalization voltage"
    # id: battery_equ_voltage
    # icon: mdi:battery-medium
    # skip_updates: ${select_skip_updates}
    # entity_category: config
    # address: 5030
    # value_type: U_WORD
    # min_value: 48.0
    # max_value: 58.4
    # step: 0.1
    # multiply: 10
    # lambda: |-
    #   if (isnan(x)) {
    #     return {};
    #   }
    #   return x; 

 # #Menu33 - 5031 Battery equalized time
  # - platform: modbus_controller
    # name: "Battery Equalized Time"
    # id: battery_equ_time
    # icon: mdi:battery-clock-outline
    # skip_updates: ${select_skip_updates}
    # entity_category: config
    # address: 5031
    # value_type: U_WORD
    # force_new_range: true
    # min_value: 5
    # max_value: 900
    # step: 5
    # lambda: |-
    #   if (isnan(x)) {
    #     return {};
    #   }
    #   return x; 

 # #Menu34 - 5032 Battery equalized timeout
  # - platform: modbus_controller
    # name: "Battery Equalized Timeout"
    # id: battery_equ_timeout
    # icon: mdi:battery-remove-outline
    # skip_updates: ${select_skip_updates}
    # entity_category: config
    # address: 5032
    # value_type: U_WORD
    # min_value: 5
    # max_value: 900
    # step: 5
    # lambda: |-
    #   if (isnan(x)) {
    #     return {};
    #   }
    #   return x; 

 # #Menu35 - 5033 Equalization interval
  # - platform: modbus_controller
    # name: "Battery Equalization interval"
    # id: battery_equ_interval
    # icon: mdi:update
    # skip_updates: ${select_skip_updates}
    # entity_category: config
    # address: 5033
    # value_type: U_WORD
    # force_new_range: true
    # min_value: 0
    # max_value: 90
    # step: 1
    # lambda: |-
    #   if (isnan(x)) {
    #     return {};
    #   }
    #   return x; 
